### 线程池

[ThreadPoolTaskExecutor使用详解](https://blog.csdn.net/foreverling/article/details/78073105)
* 什么是CPU密集型、IO密集型？
  * CPU密集型（CPU-bound)  是IO很少 cpu用的很多
  * IO密集型（I/O bound） 是IO很多 cpu用的很少

* 线程池处理流程
  * 当一个任务被提交到线程池时，首先查看线程池的核心线程是否都在执行任务，否就选择一条线程执行任务，是就执行第二步。
  * 查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第三步。
  * 查看任务队列是否已满，不满就将任务存储在任务队列中，否则执行第四步。
  * 查看线程池是否已满，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。
* sleep
  * 相当于让线程睡眠，交出CPU，让CPU去执行其他的任务 sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象
* yield 
  * 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方 法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
  * 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间
* join
  * 假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。
